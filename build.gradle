buildscript {
    dependencies {
        classpath "com.google.guava:guava:23.2-jre"
    }
}

plugins {
    id "java"
    id "jacoco"
    id "pmd"
    id "eclipse"
    id "com.github.spotbugs" version "4.7.5"
    id "org.ajoberstar.grgit" version "4.1.0"
    id "com.diffplug.spotless" version "5.11.1"
    id "org.owasp.dependencycheck" version "6.2.2"
    /*
     id "nebula.lint" version "17.1.0"
     id "nebula.resolution-rules" version "7.8.7"
     */
    id "com.github.ben-manes.versions" version "0.39.0"
}

ext {
    buildScripts="$projectDir/buildSrc"
    buildPlugins="$buildScripts/plugins"
    //make sure these files exist
    jdtInputFile="${buildScripts}/template/for/eclipse/org.eclipse.jdt.core.prefs"

    distributionDir="$buildDir/distributions"

    codeCoveragePlugin="${buildScripts}/plugins/jacoco.gradle"

    artifactVersion='3.0.7'

    distributionExcludes = ["*-lib.jar"]
    distributionBasename = 'vÃ¶lundr-distribution'

    slf4jVersion="1.7.32"
    log4jVersion="1.2.17"
    junitVersion="4.11"
    commonsIoVersion="2.11.0"
    commonsCollectionsVersion="3.2.2"
    jfreechartVersion="1.5.3"
    spotbugsVersion="4.4.1"
}

allprojects {
    repositories {
        mavenCentral()
    }
}

apply plugin : org.fluentjava.volundr.ReportingPlugin
apply plugin : org.fluentjava.volundr.JavaDistributionPlugin
apply plugin : org.fluentjava.volundr.BuildPlugin

dependencyCheck {
    skipConfigurations = [
        'jacocoAgent',
        'pmd',
        'spotbugs',
        'antClasspath'
    ]
    skipProjects = [":buildSrc"]
    cve {
        urlModified = "https://freedumbytes.gitlab.io/setup/nist-nvd-mirror/nvdcve-1.1-modified.json.gz"
        urlBase = "https://freedumbytes.gitlab.io/setup/nist-nvd-mirror/nvdcve-1.1-%d.json.gz"
    }
}

spotless {
    format 'misc', {
        target '**/*.md', '**/.gitignore'
        target.exclude '**/mukatee-osmo/**'
        trimTrailingWhitespace()
        indentWithSpaces()
        endWithNewline()
    }
    groovyGradle {
        target '**/*.gradle'
        greclipse()
        trimTrailingWhitespace()
        endWithNewline()
        indentWithSpaces()
    }
    java {
        importOrder 'java', 'javax', 'org', 'com', ''
        removeUnusedImports()
        trimTrailingWhitespace()
        indentWithSpaces()
        endWithNewline()
        eclipse().configFile "${project.properties.jdtInputFile}"
        target project.fileTree(project.rootDir) {
            include '**/*.java'
            exclude '**/build/**', '**/mukatee-osmo/**'
        }
    }
}

subprojects { prj ->
    apply plugin : 'java'
    apply plugin : 'pmd'
    apply plugin : "com.github.spotbugs"
    apply plugin : 'eclipse'
    apply plugin : 'jacoco'
    apply plugin : org.fluentjava.volundr.JavaProjectArtifactPlugin
    apply plugin : org.fluentjava.volundr.ForkEclipseJdtPlugin
    apply plugin : org.fluentjava.volundr.EclipseClasspathPlugin
    apply plugin : org.fluentjava.volundr.ProjectVersion

    spotbugs {
        toolVersion = "$spotbugsVersion"
        effort = 'max'
    }

    pmd {
        ignoreFailures = false //need to fix those
        toolVersion = "6.20.0"
        ruleSetFiles = files("${project.rootDir}/conf/pmd-ruleset.xml")
        /*
         Gradle defaults to using the basic and braces
         rulesets up to Gradle 5. Gradle 5 defaults to using
         the errorprone category.
         */
        ruleSets = []
        // https://pmd.github.io/pmd-6.20.0/pmd_userdocs_incremental_analysis.html
        //this is an incubating feature and seems to have some issues
        // disabling it for now
        //incrementalAnalysis = true
    }

    tasks.withType(com.github.spotbugs.snom.SpotBugsTask) { task ->
        task.reports {
            xml.enabled = project.hasProperty('CI') && "${CI}".toBoolean()
        }
        task.reports {
            html.enabled = !(project.hasProperty('CI') && "${CI}".toBoolean())
        }
    }

    project.plugins.apply(JacocoPlugin)

    project.task("jacocoMerge", type: JacocoMerge) {
        executionData project.tasks.withType(Test)

        doFirst {
            executionData = files(executionData.findAll { it.exists() })
        }
    }
    tasks.withType(JavaCompile) { options.encoding = 'UTF-8' }

    forkJdt { jdtInputFile = "${project.properties.jdtInputFile}"  }

    version = prj.parent.artifactVersion
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8

    dependencies {
        compileOnly "com.github.spotbugs:spotbugs-annotations:$spotbugsVersion"
        testRuntimeOnly "org.slf4j:slf4j-log4j12:${slf4jVersion}"
        testRuntimeOnly "log4j:log4j:${log4jVersion}"
    }

    jacocoTestReport {
        reports {
            xml.enabled false
            csv.enabled false
            html.destination file("${buildDir}/jacocoHtml")
        }
    }
    pmdTest {
        afterEvaluate {
            ruleSetFiles = files("${project.rootDir}/conf/pmd-ruleset-for-tests.xml")
        }
    }
}

def publishedProjects = subprojects.findAll() { it.path != ':buildSrc' }

task jacocoMerge(type: JacocoMerge) {
    destinationFile = file("${buildDir}/jacoco/merged.exec")
    publishedProjects.each { subproject ->
        executionData subproject.tasks.withType(Test)
    }

    doFirst {
        executionData = files(executionData.findAll { it.exists() })
    }
}

task jacocoAggregateReport(type: JacocoReport, group: 'Coverage reports') { rep ->
    description = 'Generates an aggregate report from all subprojects'
    dependsOn publishedProjects.test, jacocoMerge

    additionalSourceDirs.setFrom(files(publishedProjects.sourceSets.main.allSource.srcDirs))
    sourceDirectories.setFrom(files(publishedProjects.sourceSets.main.allSource.srcDirs))
    classDirectories.setFrom(files(publishedProjects.sourceSets.main.output))
    executionData.setFrom(jacocoMerge.destinationFile)

    reports {
        html.enabled = true // human readable
        xml.enabled = true // computer readable
    }

    doLast { println "Coverage report(s) can be found from file://${buildDir}/reports/jacoco/jacocoAggregateReport/html/index.html" }
}

tasks.named('wrapper') {
    distributionType = Wrapper.DistributionType.ALL
}

def isNonStable = { String group, String module, String version ->
    return (version ==~ /(?i).*[-.](alpha|beta|SNAP|milestone|M1|rc)-?[0-9]*$/)
}

subprojects {
    task allDependencies(type: DependencyReportTask) {}
}

tasks.named("dependencyUpdates").configure {
    rejectVersionIf {
        isNonStable(it.candidate.group, it.candidate.module, it.candidate.version)
    }
}
